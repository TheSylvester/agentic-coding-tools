#!/usr/bin/env bash
# gemini-agent: Non-interactive Gemini CLI wrapper.
#
# Usage:
#   gemini-agent <prompt>                         # Args as prompt
#   gemini-agent --model <model> <prompt>         # Specify model
#   gemini-agent --resume latest <prompt>         # Resume latest session
#   gemini-agent --resume <uuid> <prompt>         # Resume session by UUID
#   gemini-agent --resume 3 <prompt>              # Resume session by index
#   gemini-agent --version                        # Show version diagnostics
#   PROMPT_FILE=task.md gemini-agent              # Read from file
#   cat task.md | gemini-agent                    # Read from stdin
#
# Environment variables:
#   PROMPT_FILE          - Read prompt from this file
#   GEMINI_MODEL         - Model to use (passed as --model)
#   GEMINI_SESSION       - Session to resume ("latest", UUID, or index number)
#   GEMINI_API_KEY       - API key (alternative to OAuth)
#   GOOGLE_GENAI_USE_GCA - Set to 'true' to use Gemini Code Assist auth

set -euo pipefail

MIN_VERSION="0.20.0"

# Version comparison: returns 0 if $1 >= $2
version_gte() {
  printf '%s\n%s\n' "$2" "$1" | sort -V -C
}

# Show version diagnostics
show_diagnostics() {
  echo "" >&2
  echo "=== Diagnostics ===" >&2

  if ! command -v gemini >/dev/null 2>&1; then
    echo "gemini CLI: NOT INSTALLED" >&2
    echo "  Install with: npm install -g @google/gemini-cli" >&2
    return
  fi

  local version
  version=$(gemini --version 2>/dev/null || echo "unknown")
  echo "gemini CLI: v${version} (at $(command -v gemini))" >&2
  echo "  Min required: v${MIN_VERSION} (for --resume)" >&2

  if [[ "$version" != "unknown" ]] && ! version_gte "$version" "$MIN_VERSION"; then
    echo "  WARNING: Version too old! Run: npm install -g @google/gemini-cli@latest" >&2
  fi

  echo "" >&2
  echo "Authentication:" >&2
  [[ -n "${GEMINI_API_KEY:-}" ]] && echo "  GEMINI_API_KEY: set" >&2 || echo "  GEMINI_API_KEY: not set" >&2
  [[ -n "${GOOGLE_GENAI_USE_GCA:-}" ]] && echo "  GOOGLE_GENAI_USE_GCA: ${GOOGLE_GENAI_USE_GCA}" >&2 || echo "  GOOGLE_GENAI_USE_GCA: not set" >&2
  [[ -n "${GOOGLE_GENAI_USE_VERTEXAI:-}" ]] && echo "  GOOGLE_GENAI_USE_VERTEXAI: ${GOOGLE_GENAI_USE_VERTEXAI}" >&2 || echo "  GOOGLE_GENAI_USE_VERTEXAI: not set" >&2
  [[ -s "${HOME}/.gemini/oauth_creds.json" ]] && echo "  OAuth creds: exists" >&2 || echo "  OAuth creds: missing" >&2

  echo "" >&2
  echo "Effective auth: " >&2
  if [[ -n "${GEMINI_API_KEY:-}" ]]; then
    echo "  API key" >&2
  elif [[ -n "${GOOGLE_GENAI_USE_VERTEXAI:-}" ]]; then
    echo "  Vertex AI" >&2
  elif [[ -n "${GOOGLE_GENAI_USE_GCA:-}" ]] || [[ -s "${HOME}/.gemini/oauth_creds.json" ]]; then
    echo "  Gemini Code Assist (GCA)" >&2
  else
    echo "  NONE - run 'gemini' interactively to set up OAuth" >&2
  fi
}

MODEL="${GEMINI_MODEL:-}"
RESUME="${GEMINI_SESSION:-}"
SHOW_VERSION=false

# Parse flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    --version|-v)
      SHOW_VERSION=true
      shift
      ;;
    --model|-m)
      MODEL="$2"
      shift 2
      ;;
    --resume|-r)
      RESUME="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
  esac
done

# If --version flag, show diagnostics and exit
if [[ "$SHOW_VERSION" == "true" ]]; then
  echo "gemini-agent wrapper"
  show_diagnostics 2>&1  # redirect to stdout for --version
  exit 0
fi

# Determine prompt source: PROMPT_FILE > args > stdin
HAS_STDIN=false
[[ ! -t 0 ]] && HAS_STDIN=true
PROMPT_SOURCE=""

# Validate: PROMPT_FILE and actual stdin content are mutually exclusive
# Also catch the common mistake of PROMPT_FILE=/dev/stdin
if [[ -n "${PROMPT_FILE:-}" ]]; then
  if [[ "$PROMPT_FILE" == "/dev/stdin" || "$PROMPT_FILE" == "-" ]]; then
    echo "Error: PROMPT_FILE=/dev/stdin is not supported." >&2
    echo "" >&2
    echo "Instead, use stdin directly:" >&2
    echo "  cat task.md | gemini-agent" >&2
    echo "  gemini-agent <<'EOF'" >&2
    echo "  your prompt here" >&2
    echo "  EOF" >&2
    exit 1
  fi
  # If PROMPT_FILE is set and there's stdin content, warn (but PROMPT_FILE takes priority)
  if [[ "$HAS_STDIN" == "true" ]]; then
    # Check if stdin actually has content (non-blocking peek)
    if read -t 0 2>/dev/null; then
      echo "Warning: stdin input ignored because PROMPT_FILE is set." >&2
      echo "  Using: $PROMPT_FILE" >&2
    fi
  fi
fi

if [[ -n "${PROMPT_FILE:-}" ]]; then
  if [[ ! -f "$PROMPT_FILE" ]]; then
    echo "Error: PROMPT_FILE '$PROMPT_FILE' does not exist or is not a file." >&2
    exit 1
  fi
  PROMPT="$(cat "$PROMPT_FILE")"
  PROMPT_SOURCE="file:$PROMPT_FILE"
elif [[ $# -gt 0 ]]; then
  PROMPT="$*"
  PROMPT_SOURCE="args"
elif [[ "$HAS_STDIN" == "true" ]]; then
  PROMPT="$(cat || true)"
  PROMPT_SOURCE="stdin"
else
  echo "Usage: gemini-agent [--model <model>] [--resume latest|<uuid>|<index>] <prompt>" >&2
  echo "       gemini-agent --version" >&2
  echo "" >&2
  echo "Prompt input methods (use ONE):" >&2
  echo "  Args:       gemini-agent \"your prompt here\"" >&2
  echo "  File:       PROMPT_FILE=task.md gemini-agent" >&2
  echo "  Stdin:      cat task.md | gemini-agent" >&2
  echo "  Heredoc:    gemini-agent <<'EOF'" >&2
  echo "              your prompt" >&2
  echo "              EOF" >&2
  exit 1
fi

# Validate prompt
if [[ -z "${PROMPT//[$' \t\r\n']/}" ]]; then
  echo "Error: prompt is empty (source: ${PROMPT_SOURCE:-none})" >&2
  echo "" >&2
  echo "Prompt input methods (use ONE):" >&2
  echo "  Args:       gemini-agent \"your prompt here\"" >&2
  echo "  File:       PROMPT_FILE=task.md gemini-agent" >&2
  echo "  Stdin:      cat task.md | gemini-agent" >&2
  echo "  Heredoc:    gemini-agent <<'EOF'" >&2
  echo "              your prompt" >&2
  echo "              EOF" >&2
  exit 1
fi

# Verify gemini command exists
if ! command -v gemini >/dev/null 2>&1; then
  echo "Error: gemini command not found. Install with: npm install -g @google/gemini-cli" >&2
  show_diagnostics
  exit 1
fi

# Check version if using --resume
if [[ -n "$RESUME" ]]; then
  GEMINI_VERSION=$(gemini --version 2>/dev/null || echo "0.0.0")
  if ! version_gte "$GEMINI_VERSION" "$MIN_VERSION"; then
    echo "Error: --resume requires gemini CLI v${MIN_VERSION}+ (you have v${GEMINI_VERSION})" >&2
    echo "Update with: npm install -g @google/gemini-cli@latest" >&2
    show_diagnostics
    exit 1
  fi
fi

# Auto-detect auth: use GCA if OAuth creds exist and no explicit auth set
if [[ -z "${GEMINI_API_KEY:-}" && -z "${GOOGLE_GENAI_USE_VERTEXAI:-}" && -z "${GOOGLE_GENAI_USE_GCA:-}" ]]; then
  if [[ -s "${HOME}/.gemini/oauth_creds.json" ]]; then
    export GOOGLE_GENAI_USE_GCA=true
  else
    echo "Error: No authentication configured." >&2
    show_diagnostics
    exit 1
  fi
fi

# Build command args - use JSON output to get session_id
GEMINI_ARGS=(-y -o json)
[[ -n "$MODEL" ]] && GEMINI_ARGS+=(-m "$MODEL")
[[ -n "$RESUME" ]] && GEMINI_ARGS+=(-r "$RESUME")
GEMINI_ARGS+=(-p "$PROMPT")

# Run gemini, show diagnostics on failure
OUTPUT=$(gemini "${GEMINI_ARGS[@]}" 2>&1) || {
  EXIT_CODE=$?
  echo "Error: gemini command failed (exit code $EXIT_CODE)" >&2
  echo "" >&2

  # Show what was attempted
  echo "=== What was attempted ===" >&2
  echo "Prompt source: $PROMPT_SOURCE" >&2
  echo "Prompt length: ${#PROMPT} chars" >&2
  PROMPT_PREVIEW="${PROMPT:0:200}"
  [[ ${#PROMPT} -gt 200 ]] && PROMPT_PREVIEW="${PROMPT_PREVIEW}..."
  echo "Prompt preview: $PROMPT_PREVIEW" >&2
  echo "" >&2
  echo "Command: gemini ${GEMINI_ARGS[*]:0:3} -p <prompt>" >&2
  echo "" >&2

  # Show gemini output (filtered)
  FILTERED_OUTPUT=$(echo "$OUTPUT" | grep -v "^Data collection\|^Loaded cached\|^YOLO mode")
  if [[ -n "$FILTERED_OUTPUT" ]]; then
    echo "=== Gemini output ===" >&2
    echo "$FILTERED_OUTPUT" >&2
  fi

  show_diagnostics
  exit $EXIT_CODE
}

# Filter noise lines from output - gemini CLI prints status messages before JSON
# Use grep -v with || true to handle case where all lines are filtered
CLEAN_OUTPUT=$(echo "$OUTPUT" | grep -v "^Data collection\|^Loaded cached\|^YOLO mode\|^Hook registry\|^Attempt .* failed:" || true)

# Extract session_id and response from JSON output (which is multi-line pretty-printed)
if command -v jq >/dev/null 2>&1; then
  # jq can handle multi-line JSON directly
  SESSION_ID=$(echo "$CLEAN_OUTPUT" | jq -r '.session_id // empty' 2>/dev/null || true)
  RESPONSE=$(echo "$CLEAN_OUTPUT" | jq -r '.response // empty' 2>/dev/null || true)
else
  # Fallback: basic extraction without jq (works on pretty-printed JSON)
  SESSION_ID=$(echo "$CLEAN_OUTPUT" | grep -oP '"session_id"\s*:\s*"\K[^"]+' | head -1 || true)
  RESPONSE=$(echo "$CLEAN_OUTPUT" | grep -oP '"response"\s*:\s*"\K[^"]*' | head -1 || true)
fi

# Output response
if [[ -n "$RESPONSE" ]]; then
  echo "$RESPONSE"
else
  # If JSON parsing failed, output raw (probably error message)
  echo "$CLEAN_OUTPUT"
fi

# Output session ID for caller to capture
if [[ -n "$SESSION_ID" ]]; then
  echo ""
  echo "[session_id: $SESSION_ID]"
fi
